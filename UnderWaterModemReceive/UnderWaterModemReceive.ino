int inputPin = 9; // ножка с которой считываем сигнал

int data = 0; // Численное представление символа
byte pointerData = 7; // указатель номер посылки - степень двойки при переводе числа из бинарной системы счисления в десятичную систему счисления
byte degreesOfTwo[8] = {1, 2, 4, 8, 16, 32, 64, 128}; // массив со степенями двойки для упращения работы микроконтроллера

int actualState = 1; // Сигнал между сообщениями всегда находится в положении логической еденицы, на начало прогрммы так же является 1
bool startMessage = true; // флаг начала сообщения

unsigned long currentTime = 0; // Переменая для записи времени начала получения новой посылки

int zeroLength = 200; // длина посылки 0 в милисекундах
int oneLength = 100; // длина посылки 1 в милисекундах

int minLength = 50; // минимальная длина посылки в милисекундах
int maxLength = 2000; // максимальная длина посылки в милисекундах

void setup() 
{
  Serial.begin(115200); // устанавливаем скорость для монитора порта
  pinMode(inputPin, INPUT); // устанавливаем режим работы ножки
  currentTime = 0; // обнуляем переменную времени
}

void loop() 
{
  if (Serial.available() > 0) // если есть символ в буфере обмена
  {
    char charData = Serial.read(); // Считываем символ

    if (charData == '~') // если символ равен '~' то обнуляем все значения
    {
      // это необходимо сделать для того что бы в случии ошибки приема сигнала можно было не перезапуская код исправить ошибки
      resetAllData();
    }
  }

  int digitalData = digitalRead(inputPin); // считываем сигнал с ножки

  //Serial.println(digitalData);
  
  if (digitalData != actualState) // если новое значение сигнала отличается от актуального, то значит произошли изменеия сигнала и мы поймали или начало посылки или ее конец
  {
    //Serial.print("dData ==");
    //Serial.println(digitalData);
    
    if (digitalData == 1) // если пришло начало посылки
    {
      actualState = digitalData; // обновляем актуальное значение сигнала
      currentTime = millis(); // засекаем время когда началась посылка
    }
    else // если пришел конец посылки - начало защитного интервала
    {
      unsigned long actualTime = millis() - currentTime; // считаем время прошедшее с начала посылки

      actualState = digitalData; // обновляем актуальное значение сигнала
      int package = giveSimilarityNumber(actualTime); // получаем значение посылки основываясь на ее времени
      
      if (package == -1) // если посылка не определенна
      {
        return; // досрочно завершаем цикл микроконтроллера
      }

      dataCalculate(package); // записываем полученную посылку к числу
    }
  }
}

void dataCalculate(int n) // функция расчета численного предсавления символа
{
  data += n * degreesOfTwo[pointerData]; // прибавляем к численному предсавлению символа поылку умноженноую на 2 в степени номера посылки
  pointerData--; // смещаем указатель

  Serial.println(n);

  if(pointerData == 255) // если указатель вышел за пределы своих значений
  {
    Serial.print("data = ");
    Serial.println((char)data); // выводим символ
    data = 0; // обнуляем численное представление симола
    pointerData = 7; // указатель ставим в начальное значение
  }
}

int giveSimilarityNumber(int n) // функция возвращает посылку изходя из длины
{
  if (n < minLength || n > maxLength) return -1; // если время полученной посылки меньше или больше определенных длин, то посылка не определенна 

  // считаем к какому времени 0 или 1 ближе время посылки
  int n0 = abs(zeroLength - n);
  int n1 = abs(oneLength - n);

  return n1 < n0; // возвращаем либо 0 либо 1
}

void resetAllData() // Функция сбрасывает все значения в начальные положения
{
  data = 0;
  pointerData = 7;
  actualState = 1;
  startMessage = true;
  currentTime = 0;
}
